---
title: 'Differential Gene Expression in Systemic Sclerosis: GSE249550'
author: "Gonzalo Villanueva-Martin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages ----
```{r load packages}
suppressPackageStartupMessages({
  library(GEOquery)
  library(limma)
  library(ggplot2)
  library(preprocessCore)
  library(PCAtools)
  library(factoextra)
  library(tidyr)
  library(msigdbr)
  library(fgsea)
  library(enrichR)
  library(reshape2)
  library(tibble)
  library(openxlsx)
  library(AnnotationDbi)
  library(org.Hs.eg.db)
  library(GhibliBrewer)
  library(stringr)
  library(dplyr)
})
```

# 1) Download GEO GSE249550 series matrix ----
```{r}
gse_id <- "GSE249550"
gset <- GEOquery::getGEO(gse_id, getGPL = FALSE)[[1]]  # Series Matrix, typically already log2-like
eset <- gset
```

# 2) Define phenotype and groups explicitly ----
```{r}
ph <- pData(eset)
ph %>% colnames
ph %>% head(n=2)
```


```{r}
ph_summ <- ph %>%
  select(characteristics_ch2.1,characteristics_ch2.3,characteristics_ch2.4) %>%
  group_by(characteristics_ch2.1,characteristics_ch2.3,characteristics_ch2.4) %>%
  summarise(n = n(), .groups = "drop")

ph_summ
```


# Create a clean group label:
```{r}
ph$Group <- case_when(
  grepl("disease state: Healthy", ph$characteristics_ch2.1, ignore.case = TRUE) ~ "Control",
  grepl("disease state: SSc", ph$characteristics_ch2.1, ignore.case = TRUE) ~ "SSc",
  TRUE ~ "Other")

```


# Keep only Control vs SSc for this contrast:
```{r}
#ph_raw <- ph
#ph <- ph %>% filter(!Condition == "SSc-PAH") # Excluding PAH patients
```

# 3) Expression matrix (log-scale)  ----
```{r}
E <- exprs(eset)  # For Series Matrix, values are usually already normalized/log2
summary(as.numeric(exprs(eset)))
# Optional sanity check: if range(E) > ~50 then not log; but for arrays, Series Matrix is log-like.
```
```{r}
# ==========================================================
# Diagnostics: Is the matrix already quantile-normalized?
# ==========================================================

library(matrixStats)

E0 <- exprs(eset)  # original matrix

# 1) Per-sample quartiles: Q1, median, Q3
#    If quantile-normalized, quartiles should be (nearly) identical across samples
quart_mat <- sapply(colnames(E0), function(s) {
  quantile(E0[, s], probs = c(0.25, 0.5, 0.75), na.rm = TRUE, type = 7)
})
colnames(quart_mat) <- colnames(E0)
rownames(quart_mat) <- c("Q1","Median","Q3")

# Spread of quartiles across samples
quart_spread <- apply(quart_mat, 1, function(q) max(q) - min(q))
quart_sd     <- apply(quart_mat, 1, sd)

cat("Quartile spread (max-min) across samples:\n")
print(round(quart_spread, 6))
cat("\nQuartile SD across samples:\n")
print(round(quart_sd, 6))

# 2) Fine-grained check: SD of empirical quantiles across samples (0..1 by 1%)
probs <- seq(0, 1, by = 0.01)
Q <- sapply(colnames(E0), function(s) quantile(E0[, s], probs = probs, na.rm = TRUE))
sd_per_prob <- rowSds(Q)  # SD across samples at each probability

cat("\nMedian SD across probs:", round(median(sd_per_prob), 6),
    " | 95th perc SD:", round(quantile(sd_per_prob, 0.95), 6), "\n")

# 3) Idempotence test: apply quantile normalization and measure change
suppressPackageStartupMessages(library(preprocessCore))
E1 <- normalize.quantiles(as.matrix(E0))
dimnames(E1) <- dimnames(E0)

delta <- E1 - E0
max_abs_delta   <- max(abs(delta), na.rm = TRUE)
median_abs_delta<- median(abs(delta), na.rm = TRUE)

cat("\nIdempotence check (after normalize.quantiles vs original):",
    "\n  max |Δ| =", round(max_abs_delta, 6),
    "\n  median |Δ| =", round(median_abs_delta, 6), "\n")

# 4) Simple rule-of-thumb decision
#    - If quartile SDs are near zero and SD of quantiles across samples is tiny,
#      and idempotence change is ~0, then it's already quantile-normalized.
already_qn <- (all(quart_sd < 1e-3)) &&
              (quantile(sd_per_prob, 0.95) < 1e-3) &&
              (max_abs_delta < 1e-6)

cat("\nDecision:",
    if (already_qn) "Matrix appears already quantile-normalized."
    else "Matrix likely not fully quantile-normalized.", "\n")
```

The matrix is not normalize but it is scale.
```{r}
#if (max(E, na.rm = TRUE) > 100) {
#  E <- log2(E + 1)
#}
```

## Quantile normalization
```{r}
E <- normalize.quantiles(E)
rownames(E) <- featureNames(eset)
colnames(E) <- sampleNames(eset)
#exprs(eset) <- E
```

```{r}
# For Series Matrix, values are usually already normalized/log2
summary(as.numeric(E))
# Optional sanity check: if range(E) > ~50 then not log; but for arrays, Series Matrix is log-like.
```

```{r}
boxplot(E, las = 2, main = "Norm", col = "grey90")
```

```{r}
hist(as.numeric(E), breaks = 100, main = "Expression value distribution")
```
```{r quantile_norm_check, message=FALSE}
# Compare standard deviations before/after quantile normalization
sd_before <- apply(exprs(eset), 2, sd)
sd_after  <- apply(E, 2, sd)

data.frame(
  Sample = colnames(E),
  SD_before = sd_before,
  SD_after = sd_after
)
```

## Illumina probes IDs to genes
```{r} 
gpl_id <- ph$platform_id %>% unique()
gpl <- GEOquery::getGEO(gpl_id, AnnotGPL = TRUE)
class(gpl)
```

```{r}
# 1) Download platform table
tbl <- Table(gpl)
head(tbl)

# 2) Identify ID and symbol columns automatically
id_col  <- grep("^(ID|ID_REF|ILMN)", names(tbl), ignore.case = TRUE, value = TRUE)[1]
sym_col <- grep("symbol", names(tbl), ignore.case = TRUE, value = TRUE)[1]

cat("Using columns:", id_col, "->", sym_col, "\n")

# 3) Build mapping
map_df <- tbl[, c(id_col, sym_col)]
colnames(map_df) <- c("PROBEID", "SYMBOL")
map_df$SYMBOL[map_df$SYMBOL %in% c("", "NA")] <- NA
```


# 4) PCA (no CPM; this is microarray) ----
```{r}
pc_dat <- t(E)  # samples x genes
pca <- prcomp(pc_dat, scale. = TRUE)
pc_df <- data.frame(pca$x[, 1:2], Group = ph$Group, Sample = rownames(pc_dat),Treatment  = ph$`treatment:ch2`, SampleID = ph$title)
```

```{r}
# Number of samples (or groups) to color
n_colors <- length(unique(ph$title))

# and interpolate it to the number of needed colors
palette_colors <- ghibli.brewer("Totoro-School",n=n_colors)

# Assign colors to each sample title
sample_colors <- setNames(palette_colors, unique(ph$title))
```


```{r}
ggplot(pc_df, aes(PC1, PC2, color = Group, label = Sample)) +
  geom_point(size = 2) +
  theme_bw() +
  guides(color = guide_legend(override.aes = list(size = 3)))
```

```{r}
ggplot(pc_df, aes(PC1, PC2, color = Treatment, label = Sample)) +
  geom_point(size = 2) +
  theme_bw() +
  guides(color = guide_legend(override.aes = list(size = 3)))
```

```{r}
ggplot(pc_df, aes(PC1, PC2, color = SampleID, label = Sample)) +
  geom_point(size = 2) +
  theme_bw() +
  scale_color_manual(values = sample_colors)
```

```{r}
cond <- as.factor(ph$Group)

#PCA plot with ellipses using fviz (FactoMineR)
pc_plot2 <- fviz_pca_ind(pca, label = 'none', col.ind = cond,
                  palette = "Rainbow", addEllipses = TRUE) +
  theme_bw()

plot(pc_plot2)
```
```{r}
cond <- as.factor(ph$`treatment:ch2`)

#PCA plot with ellipses using fviz (FactoMineR)
pc_plot2 <- fviz_pca_ind(pca, label = 'none', col.ind = cond,
                  palette = "Rainbow", addEllipses = TRUE) +
  theme_bw()

plot(pc_plot2)
```

# 5) Differential expression with limma ----
```{r}
design <- model.matrix(~ 0 + ph$Group)
colnames(design) <- unique(ph$Group)  # "Control", "SSc"
fit <- lmFit(E, design)
contrast.matrix <- makeContrasts(SSc_vs_Control = SSc - Control, levels = design)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)

tt <- topTable(fit2, coef = "SSc_vs_Control", number = Inf, adjust.method = "BH")
```

```{r}
tt %>% head()
```

```{r}
tt$X <- rownames(tt)
t <- merge(tt,map_df, by.x="X",by.y="PROBEID")
```

```{r}
res2_ann <- t
res2_ann$significance <- case_when(
  res2_ann$adj.P.Val < 0.05 & res2_ann$logFC > 0.5  ~ "Upregulated",
  res2_ann$adj.P.Val < 0.05 & res2_ann$logFC < -0.5 ~ "Downregulated",
  TRUE ~ "Not_significant"
)
res2_ann$delabel <- NA
res2_ann$delabel[res2_ann$significance != "Not_significant"] <- res2_ann$SYMBOL[res2_ann$significance != "Not_significant"]
```

```{r, fig.height= 4.5, fig.width= 7}
fdr_threshold <- -log2(max(res2_ann$P.Value[res2_ann$P.Value <= 0.05], na.rm = TRUE))
volplot <- ggplot(res2_ann, aes(x = logFC, y = -log2(adj.P.Val), color= significance,label = delabel)) +
  geom_point(alpha = 0.6) + 
  scale_color_manual(values = c("Upregulated" = "#7FB77E", 
                                "Downregulated" = "#9730AF", "Not_significant" = "#bdbdbd")) +  
  theme_minimal() +  
  labs(title = "", 
       x = "LFC", 
       y = "-log2(p-value)",
       fill="",
       color="") +
  geom_label_repel(data = filter(res2_ann, !is.na(delabel)),, color = "black",
                   max.overlaps = 10, force = 5, size = 3, show.legend = FALSE) +
  scale_fill_manual(values = c("Upregulated" = "#7FB77E", 
                               "Downregulated" = "#da5cf7", "Not_significant" = "#bdbdbd")) +
  geom_hline(yintercept = 4.321928, linetype = "dashed", color = "blue")+
  geom_vline(xintercept = c(-0.5,0.5), linetype = "dashed", color = "red")
volplot
```

```{r, fig.height= 4, fig.width= 5}
# Box plot as sanity check
gene <- map_df %>% filter(SYMBOL == 'COL4A1')
geneName <- unique(gene$SYMBOL)
E_fil <- as.data.frame(E) %>% filter(rownames(E) == gene$PROBEID) %>% t() %>% as.data.frame()
colnames(E_fil) <- "gene"
df <- cbind(E_fil,ph)

plot.title <- paste0("Expression of ",geneName," in SSc vs CTRLs in ",gse_id) 

ggplot(df, aes(x = Group, y = gene, color = Group)) +
  geom_dotplot(binaxis = "y", stackdir = "center",aes(fill=Group))+
  geom_boxplot(width=0.3,alpha = 0.5)+
  ylab("Microarray expression")+
  xlab("")+
  theme_bw()+
  theme(legend.position = "")+
  ggtitle(plot.title)
```

#### saving the results
```{r}
filename_de <- paste0("../results/dea/DE_results_",gse_id,".txt")
write.table(res2_ann,filename_de,quote = F,append = F,sep = "\t",row.names = F,col.names = T)
```

# 6) Pathway analysis
```{r}
# All C2 pathways
c2_all <- msigdbr(species = "Homo sapiens", category = "C2")

# KEGG
kegg <- c2_all %>%
  filter(gs_subcat == "CP:KEGG") %>%
  split(.$gene_symbol, .$gs_name)

# Reactome
react <- c2_all %>%
  filter(gs_subcat == "CP:REACTOME") %>%
  split(.$gene_symbol, .$gs_name)

# WikiPathways
wp <- c2_all %>%
  filter(gs_subcat == "CP:WP") %>%
  split(.$gene_symbol, .$gs_name)

# Hallmark (similar a "canon" del script original)
hallmark <- msigdbr(species="human", category="H")
H_gene_sets <- msigdbr(species = "human", category = 'H')

H.ensembl.ls <- H_gene_sets %>% 
  select(gs_name, gene_symbol) %>% 
  group_by(gs_name) %>% 
  summarise(all.genes = list(unique(gene_symbol))) %>% 
  deframe()
```

```{r}
# Ranking the genes for GSEA
ranking <- setNames(res2_ann$logFC, res2_ann$SYMBOL) # asign to each gene its OR
```

```{r}
gsea.H <- fgseaMultilevel(pathways = H.ensembl.ls, 
                           stats=ranking,  
                           minSize = 10, 
                           maxSize = 500)
```

```{r}
fgseaResTidy <- gsea.H %>%
  as_tibble() %>%
  arrange(desc(NES))

# Show in a nice table:
fgseaResTidy %>% 
  dplyr::select(-leadingEdge, -ES) %>% 
  arrange(padj) %>% 
  DT::datatable()
```

```{r}
top_pos.H <- gsea.H %>%
  filter(padj < 0.1) %>%
  filter(NES > 0) %>%
  arrange(desc(NES)) %>%
  slice_head(n = 20)

top_neg.H <- gsea.H %>%
  filter(padj < 0.1) %>%
  filter(NES < 0) %>%
  arrange(NES) %>%
  slice_head(n = 20)

top_combined.H <- bind_rows(top_pos.H, top_neg.H)
```

```{r, fig.height= 10, fig.width= 18}
  gsea.H.plot <- ggplot(top_combined.H, aes(reorder(pathway, NES), NES)) +
    geom_col(aes(fill = ifelse(NES > 0, "NES > 0", "NES < 0")), alpha = 0.8,width = 0.75,colour="black") +
    scale_fill_manual(values = c("NES > 0" = "#FF7F50", "NES < 0" = "#6495ED"), name = "FDR 5%") +
    coord_flip() +
    labs(x = "Pathway", y = "Normalized Enrichment Score",
         title = paste0("Hallmark top pathways in ",gse_id)) + 
    theme_bw() +
    theme(
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12,face = "bold"),
      axis.title = element_text(size = 14),
      legend.position = "top",
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )
  #ggsave(filename = GSEA.H.name, plot = gsea.H.plot ,width = 12, height = 6, dpi = 300)
  print(gsea.H.plot)
```

## C2
Extract the pathways from the database
```{r C2 analysis}
c2_gene_sets = msigdbr(species = "human", category = 'C2')

react <- c2_gene_sets %>%
  filter(gs_subcollection == "CP:REACTOME") %>%
  select(gs_name, gene_symbol) %>% 
  group_by(gs_name) %>% 
  summarise(all.genes = list(unique(gene_symbol))) %>% 
  deframe()

C2.ensembl.ls <- c2_gene_sets %>% 
  select(gs_name, gene_symbol) %>% 
  group_by(gs_name) %>% 
  summarise(all.genes = list(unique(gene_symbol))) %>% 
  deframe()


```
Run GSEA
```{r GSEA}
gsea.c2 <- fgseaMultilevel(pathways= react,
                           stats=ranking,  
                           minSize = 10, 
                           maxSize = 500)
head(gsea.c2[order(pval), ])
```
Show the results in a nice table
```{r C2 interactive table}
fgseaResTidy <- gsea.c2 %>%
  as_tibble() %>%
  arrange(desc(NES))

# Show in a nice table:
fgseaResTidy %>% 
  dplyr::select(-leadingEdge, -ES) %>% 
  arrange(padj) %>% 
  DT::datatable()
```

### Neutrophils and Platelets pathways
```{r}
# Searching for NEUTROPHILS AND PLATELET terms in the pathway, in case the are not among the top terms
neu_p.term <- grep("(NEUTROPHIL|PLATELET)",gsea.c2$pathway,ignore.case = TRUE, value = TRUE)
neu_terms <- gsea.c2 %>% 
  filter(pathway %in% neu_p.term) %>%
  filter(padj < 0.1) %>%
  arrange(desc(NES))
neu_terms
```

Select the top pathways
```{r C2 top pathways selection}
top_pos <- gsea.c2 %>%
  filter(padj < 0.1) %>%
  filter(NES > 0) %>%
  arrange(desc(NES)) %>%
  slice_head(n = 10)

top_neg <- gsea.c2 %>%
  filter(padj < 0.1) %>%
  filter(NES < 0) %>%
  arrange(NES) %>%
  slice_head(n = 10)

top_combined <- bind_rows(top_pos, top_neg)
```

### Plot the results using the Normalize Enrichment Score
```{r, fig.height= 10, fig.width= 18}
  gsea.c2.plot <- ggplot(top_combined, aes(reorder(pathway, NES), NES)) +
    geom_col(aes(fill = ifelse(NES > 0, "NES > 0", "NES < 0")), alpha = 0.8,width = 0.75,colour="black") +
    scale_fill_manual(values = c("NES > 0" = "#FF7F50", "NES < 0" = "#6495ED"), name = "FDR 10%") +
    coord_flip() +
    labs(x = "Pathway", y = "Normalized Enrichment Score",
         title = paste0("REACTOME top pathways in ",gse_id)) + 
    theme_bw() +
    theme(
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12,face = "bold"),
      axis.title = element_text(size = 14),
      legend.position = "top",
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )

gsea.c2.plot
```

```{r}
plotEnrichment(react[["REACTOME_NEUTROPHIL_DEGRANULATION"]],
               ranking) + labs(title="Neutrophil Degranulation")
```

```{r}
padj_val <- gsea.c2 %>%
  filter(pathway == "REACTOME_NEUTROPHIL_DEGRANULATION") %>%
  pull(padj)
padj_val <- signif(padj_val[1], 3)
padj_val
```

```{r}
plotEnrichment(react[["REACTOME_NEUTROPHIL_DEGRANULATION"]], ranking) +
  labs(
    title = "Neutrophil Degranulation",
    subtitle = paste("Adjusted p-value:", padj_val)
  )
```

```{r, fig.height= 10, fig.width= 18}
topPathwaysUp <- gsea.c2[ES > 0][head(order(pval), n=10), pathway]
topPathwaysDown <- gsea.c2[ES < 0][head(order(pval), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(react[topPathways], ranking, gsea.c2, 
              gseaParam=0.5)
```

```{r, fig.height= 4, fig.width= 16}
neu_terms_p <- neu_terms$pathway
plotGseaTable(react[neu_terms_p], ranking, gsea.c2, 
              gseaParam=0.5)
```

```{r}
filename_fgsea <- paste0("../results/fgsea/REACTOME_results_",gse_id,".txt")
gs_clean <- gsea.c2 %>%
  mutate(across(where(is.list), ~ sapply(., function(x) paste(x, collapse = ","))))
write.table(gs_clean, filename_fgsea, quote = FALSE, sep = "\t", row.names = FALSE)
```