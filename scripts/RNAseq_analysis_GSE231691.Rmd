---
title: 'Differential Gene Expression in Systemic Sclerosis: GSE231691'
author: "Gonzalo Villanueva-Martin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages 
```{r load packages}
suppressPackageStartupMessages({
  library(GEOquery)
  library(edgeR)
  library(limma)
  library(ggplot2)
  library(preprocessCore)
  library(PCAtools)
  library(factoextra)
  library(tidyr)
  library(msigdbr)
  library(fgsea)
  library(enrichR)
  library(reshape2)
  library(tibble)
  library(openxlsx)
  library(AnnotationDbi)
  library(org.Hs.eg.db)
  library(GhibliBrewer)
  library(dplyr)
  library(matrixStats)
  library(reshape)
  library(purrr)
  library(pheatmap)
  library(readr)
})
```

```{r}
select_window<-function(omean,osd){
  par(mar = c(5,5,2,2))
  plot(row_mean, row_sd, xlab = "Mean log2cpm", ylab = "SD", cex.lab = 1.5, cex.axis = 1.5)
  abline(v = omean, col = "red", lwd = 2)
  abline(h = osd, col = "red", lwd = 2)
  posFilt <- which(row_mean > omean & row_sd > osd)
  print(paste("Number of selected omic instances to compute PCA:",length(posFilt),sep=" "))
  dev.off()
  return(posFilt)
}
```

# 1) Download GEO GSE231691 series matrix
```{r}
gse_id <- "GSE231691"
gset <- GEOquery::getGEO(gse_id, getGPL = FALSE)[[1]]  # Series Matrix, typically already log2-like
eset <- gset
```

# 2) Define phenotype and groups explicitly
```{r}
ph <- pData(eset)
ph %>% colnames
ph %>% head(n=2)
```

```{r}
ph_summ <- ph %>%
  select(`disease state:ch1`) %>%
  group_by(`disease state:ch1`) %>%
  summarise(n = n(), .groups = "drop")

ph_summ
```

```{r}
samplesNames <- paste0(rownames(ph),"_",ph$title,".txt")
samples_s <- as.vector(ph$geo_accession)
```

### Create a clean group label:
```{r}
ph$Group <- case_when(
  grepl("normal", ph$`disease state:ch1`, ignore.case = TRUE) ~ "Control",
  grepl("systemic sclerosis", ph$`disease state:ch1`, ignore.case = TRUE) ~ "SSc",
  TRUE ~ "Other"
)
```

# 3) Expression matrix (log-scale)
As this is a RNA-seq study, we need to download the count matrix from GEO in our local directory
```{r}
counts <- read_tsv("../data/GSE231691_raw_counts_GRCh38.p13_NCBI.tsv")
```

```{r}
map <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys =  as.character(counts$GeneID),
  keytype = "ENTREZID",
  columns = c("SYMBOL")
)
map <- map[!duplicated(map$ENTREZID), ]
```

```{r}
counts_mat <- as.matrix(counts)
rownames(counts_mat) <- counts_mat[,1]
counts_mat <- counts_mat[,-1]
counts_mat<-counts_mat[ ,colnames(counts_mat) %in% samples_s]
```

```{r}
count_summary<-t(apply(counts_mat, 2, summary))
print(count_summary)
```

# 4) QC
```{r}
# removing NAs
counts_mat[is.na(counts_mat)] <- 0
# 0) Build DGEList
dge <- DGEList(counts = counts_mat)

# 1) Basic library size QC
lib_sizes <- colSums(dge$counts)

# Plot library sizes
barplot(lib_sizes, las = 2,
        main = "Library sizes per sample",
        ylab = "Number of reads")

```

```{r}
# 2) Filter lowly-expressed genes
keep <- filterByExpr(dge)
dge <- dge[keep, , keep.lib.sizes = FALSE]

# 3) Normalize using TMM
dge <- calcNormFactors(dge)

# 4) Compute logCPM for QC (not for modeling)
logCPM <- cpm(dge, log=TRUE, prior.count = 1)

```

```{r}
norm_count_long <- melt(logCPM) # long format
#plotting=

desplot <- ggplot(norm_count_long, aes(x = value, color = X2)) +
  geom_density() +
  theme_minimal() +
  theme(legend.position = "")
print(desplot)
```

```{r}
mean_t <- 1 # usual values
sd_t <- 1

row_sd <- apply(logCPM, 1, sd)
row_mean <- rowMeans(logCPM)
print(paste("Showing selection window for mean ",mean_t, " and sd ",sd_t,sep=""))
```

```{r}
posFilt<-select_window(mean_t,sd_t) 
```

```{r}
dataScatter <- data.frame(
  SD = row_sd,
  Mean = row_mean
)

scaPlot <- ggplot(dataScatter, aes(x = Mean, y = SD)) +
  geom_point(color = "black", alpha = 0.4) +  # Añadir los puntos en negro
  labs(x = "Mean of normalized counts", 
       y = "Standard Deviation", 
       title = "Scatter Plot of Mean vs SD of RNA-seq CPM") + 
  geom_vline(aes(xintercept = mean_t), color = "red") +  
  geom_hline(aes(yintercept = sd_t), color = "blue") +  
  theme_minimal()
print(scaPlot)
```

```{r}
logCPM_fil <- logCPM[rownames(logCPM) %in% names(posFilt), ]
```

# 5) PCA 
## 5.1) Only the more variable genes
```{r}
logCPM_fil <- logCPM[rownames(logCPM) %in% names(posFilt), ]
logCPM_fil <- logCPM_fil[ ,colnames(logCPM_fil) %in% samples_s]
```

```{r}
pc_dat <- t(logCPM_fil)  # samples x genes
pca <- prcomp(pc_dat, scale. = TRUE)
pc_df <- data.frame(pca$x[, 1:2], 
                    Group = ph$Group, 
                    Sample = rownames(pc_dat), 
                    SampleID = ph$title)
```

```{r}
# Number of samples (or groups) to color
n_colors <- length(unique(ph$title))

# and interpolate it to the number of needed colors
palette_colors <- ghibli.brewer("Totoro-School",n=n_colors)

# Assign colors to each sample title
sample_colors <- setNames(palette_colors, unique(ph$title))
```

```{r}
ggplot(pc_df, aes(PC1, PC2, color = Group, label = Sample)) +
  geom_point(size = 2) +
  theme_bw() +
  guides(color = guide_legend(override.aes = list(size = 3)))
```

```{r, fig.height= 5, fig.width= 10}
ggplot(pc_df, aes(PC1, PC2, color = SampleID, label = Sample)) +
  geom_point(size = 2) +
  theme_bw() +
  scale_color_manual(values = sample_colors)
```

```{r, fig.height= 5, fig.width= 7}
cond <- as.factor(ph$Group)

#PCA plot with ellipses using fviz (FactoMineR)
pc_plot2 <- fviz_pca_ind(pca, label = 'none', col.ind = cond,
                  palette = "Rainbow", addEllipses = TRUE) +
  theme_bw()

plot(pc_plot2)
```

```{r}
logCPM_1 <- logCPM
old_names <- colnames(logCPM_1)          
new_names <- ph$title[match(old_names, ph$geo_accession)]

colnames(logCPM_1) <- new_names
```

```{r, fig.height= 10, fig.width= 10}
dist_mat <- dist(t(logCPM_1))
dist_mat <- as.matrix(dist_mat)

pheatmap(dist_mat,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         main = "Sample-to-sample distances")
```

```{r}
# I should fix the names for this plot to be comprehensive
plotMDS(dge, top=500, col=as.numeric(ph$Group),
        main="MDS plot of RNA-seq samples")
```

## 5.2) All the genes
```{r}
# Build PCA object
logCPM_fil2 <- logCPM[ ,colnames(logCPM) %in% samples_s]
pc_dat <- t(logCPM_fil2)  # samples x genes
pca <- prcomp(pc_dat, scale. = TRUE)

# Percent variance explained
percentVar <- pca$sdev^2 / sum(pca$sdev^2)

pc_df <- data.frame(pca$x[, 1:2], 
                    Group = ph$Group, 
                    Sample = colnames(logCPM_fil2),
                    SampleID = ph$title)
```

```{r}
cond <- as.factor(ph$Group)

#PCA plot with ellipses using fviz (FactoMineR)
pc_plot2 <- fviz_pca_ind(pca, label = 'none', col.ind = cond,
                  palette = "Rainbow", addEllipses = TRUE) +
  theme_bw()

plot(pc_plot2)
```

```{r}
old_names <- colnames(logCPM)          
new_names <- ph$title[match(old_names, ph$geo_accession)]

colnames(logCPM) <- new_names
```

```{r, fig.height= 10, fig.width= 10}
dist_mat <- dist(t(logCPM))
dist_mat <- as.matrix(dist_mat)

pheatmap(dist_mat,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         main = "Sample-to-sample distances")
```

```{r}
# I should fix the names for this plot to be comprehensive
plotMDS(dge, top=500, col=as.numeric(ph$title),
        main="MDS plot of RNA-seq samples")
```

# 6) DEA
## 6.1) DEA with limma
What DGEList does?
Create a matrix for the raw counts, and an info df with the sample info, the library size and the normalization factors. EdgeR/limma will use this info and format to do CPM normalization and calculate the DEA using a lineal model.
```{r}
# ==========================================================
# limma-voom differential expression analysis
# Input: counts_mat (raw counts), ph (sample metadata)
# ==========================================================

# 1) Ensure counts are integer and non-negative
stopifnot(all(counts_mat >= 0))
mode(counts_mat) <- "integer"

# 2) Build DGEList object
#    ph$Group should be a factor with your conditions (e.g., "Control", "SSc")
group <- ph$Group
group <- factor(group)

dge <- DGEList(counts = counts_mat, group = group)

# 3) Filter lowly expressed genes (recommended for RNA-seq)
#    This keeps genes with sufficient counts in at least some samples
keep <- filterByExpr(dge, group = group)
dge <- dge[keep, , keep.lib.sizes = FALSE]

# 4) Normalize library sizes (TMM normalization)
dge <- calcNormFactors(dge, method = "TMM")

# 5) Design matrix for limma
design <- model.matrix(~ 0 + group)
colnames(design) <- levels(group)
design %>% head()
```

EdgeR-Limma explanation:
What is voom doing?

Counts are transformed to log2 counts per million reads (CPM), where “per million reads” is defined based on the normalization factors we calculated earlier
A linear model is fitted to the log2 CPM for each gene, and the residuals are calculated
A smoothed curve is fitted to the sqrt(residual standard deviation) by average expression (see red line in plot above)
The smoothed curve is used to obtain weights for each gene and sample that are passed into limma along with the log2 CPMs.

```{r}
# 6) voom transformation (internally uses log2-CPM with precision weights)
v <- voom(dge, design = design, plot = TRUE)

# 7) Fit linear model
fit <- lmFit(v, design)

# 8) Set up contrasts (example: SSc vs Control)
contrast.matrix <- makeContrasts(
  SSc_vs_Control = SSc - Control,
  levels = design
)

fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)

# 9) Extract top differentially expressed genes
tt <- topTable(fit2, coef = "SSc_vs_Control",
               number = Inf, adjust.method = "BH")

head(tt)
```

## 6.2) Plotting the DEA results
```{r}
tt$ENTREZID <- rownames(tt)
t <- merge(tt,map, by="ENTREZID")
```

```{r}
res2_ann <- t
res2_ann$significance <- case_when(
  res2_ann$adj.P.Val < 0.05 & res2_ann$logFC > 0.5  ~ "Upregulated",
  res2_ann$adj.P.Val < 0.05 & res2_ann$logFC < -0.5 ~ "Downregulated",
  TRUE ~ "Not_significant"
)
res2_ann$delabel <- NA
res2_ann$delabel[res2_ann$significance != "Not_significant"] <- res2_ann$SYMBOL[res2_ann$significance != "Not_significant"]
```

```{r, fig.height= 4, fig.width= 9}
fdr_threshold <- -log2(max(res2_ann$P.Value[res2_ann$P.Value <= 0.05], na.rm = TRUE))
volplot <- ggplot(res2_ann, aes(x = logFC, y = -log2(adj.P.Val), color= significance,label = delabel)) +
  geom_point(alpha = 0.6) + 
  scale_color_manual(values = c("Upregulated" = "#7FB77E", 
                                "Downregulated" = "#9730AF", "Not_significant" = "#bdbdbd")) +  
  theme_minimal() +  
  labs(title = "", 
       x = "LFC", 
       y = "-log2(p-value)",
       fill="",
       color="") +
  geom_label_repel(data = filter(res2_ann, !is.na(delabel)),, color = "black",
                   max.overlaps = 30, force = 5, size = 3, show.legend = FALSE) +
  scale_fill_manual(values = c("Upregulated" = "#7FB77E", 
                               "Downregulated" = "#da5cf7", "Not_significant" = "#bdbdbd")) +
  geom_hline(yintercept = 4.321928, linetype = "dashed", color = "blue")+
  geom_vline(xintercept = c(-0.5,0.5), linetype = "dashed", color = "red")
volplot
```

```{r, fig.height= 4, fig.width= 5}
# Box plot as sanity check
gene <- map %>% filter(SYMBOL == 'S100A8')
geneName <- unique(gene$SYMBOL)

logCPM_fil2 <- as.data.frame(logCPM)
logCPM_fil2 <- logCPM_fil2 %>%
  filter(rownames(logCPM) == gene$ENTREZID) %>%
  t() %>% 
  as.data.frame()

colnames(logCPM_fil2) <- "gene"
df <- cbind(logCPM_fil2,ph)

plot.title <- paste0("Expression of ",geneName," in SSc vs CTRLs in ",gse_id) 

ggplot(df, aes(x = Group, y = gene, color = Group)) +
  geom_dotplot(binaxis = "y", stackdir = "center",aes(fill=Group))+
  geom_boxplot(width=0.3,alpha = 0.5)+
  ylab("log2CPM expression")+
  xlab("")+
  theme_bw()+
  theme(legend.position = "")+
  ggtitle(plot.title)
```


#### saving the results
```{r}
filename_de <- paste0("../results/dea/DE_results_",gse_id,".txt")
write.table(res2_ann,filename_de,quote = F,append = F,sep = "\t",row.names = F,col.names = T)
```

# 7) Pathway analysis

```{r}
# All C2 pathways
c2_all <- msigdbr(species = "Homo sapiens", category = "C2")

# KEGG
kegg <- c2_all %>%
  filter(gs_subcat == "CP:KEGG") %>%
  split(.$gene_symbol, .$gs_name)

# Reactome
react <- c2_all %>%
  filter(gs_subcat == "CP:REACTOME") %>%
  split(.$gene_symbol, .$gs_name)

# WikiPathways
wp <- c2_all %>%
  filter(gs_subcat == "CP:WP") %>%
  split(.$gene_symbol, .$gs_name)

# Hallmark (similar a "canon" del script original)
hallmark <- msigdbr(species="human", category="H")
H_gene_sets <- msigdbr(species = "human", category = 'H')

H.ensembl.ls <- H_gene_sets %>% 
  select(gs_name, gene_symbol) %>% 
  group_by(gs_name) %>% 
  summarise(all.genes = list(unique(gene_symbol))) %>% 
  deframe()
```

```{r}
# Ranking the genes for GSEA
ranking <- setNames(res2_ann$logFC, res2_ann$SYMBOL) # asign to each gene its OR
```

```{r}
gsea.H <- fgseaMultilevel(pathways = H.ensembl.ls, 
                           stats=ranking,  
                           minSize = 10, 
                           maxSize = 500)
```

```{r}
fgseaResTidy <- gsea.H %>%
  as_tibble() %>%
  arrange(desc(NES))

# Show in a nice table:
fgseaResTidy %>% 
  dplyr::select(-leadingEdge, -ES) %>% 
  arrange(padj) %>% 
  DT::datatable()
```

```{r}
top_pos.H <- gsea.H %>%
  filter(padj < 0.1) %>%
  filter(NES > 0) %>%
  arrange(desc(NES)) %>%
  slice_head(n = 20)

top_neg.H <- gsea.H %>%
  filter(padj < 0.1) %>%
  filter(NES < 0) %>%
  arrange(NES) %>%
  slice_head(n = 20)

top_combined.H <- bind_rows(top_pos.H, top_neg.H)
```

```{r, fig.height= 10, fig.width= 18}
  gsea.H.plot <- ggplot(top_combined.H, aes(reorder(pathway, NES), NES)) +
    geom_col(aes(fill = ifelse(NES > 0, "NES > 0", "NES < 0")), alpha = 0.8,width = 0.75,colour="black") +
    scale_fill_manual(values = c("NES > 0" = "#FF7F50", "NES < 0" = "#6495ED"), name = "FDR 5%") +
    coord_flip() +
    labs(x = "Pathway", y = "Normalized Enrichment Score",
         title = paste0("Hallmark top pathways in ",gse_id)) + 
    theme_bw() +
    theme(
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12,face = "bold"),
      axis.title = element_text(size = 14),
      legend.position = "top",
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )
  #ggsave(filename = GSEA.H.name, plot = gsea.H.plot ,width = 12, height = 6, dpi = 300)
  print(gsea.H.plot)
```

## C2
Extract the pathways from the database
```{r C2 analysis}
c2_gene_sets = msigdbr(species = "human", category = 'C2')

react <- c2_gene_sets %>%
  filter(gs_subcollection == "CP:REACTOME") %>%
  select(gs_name, gene_symbol) %>% 
  group_by(gs_name) %>% 
  summarise(all.genes = list(unique(gene_symbol))) %>% 
  deframe()

C2.ensembl.ls <- c2_gene_sets %>% 
  select(gs_name, gene_symbol) %>% 
  group_by(gs_name) %>% 
  summarise(all.genes = list(unique(gene_symbol))) %>% 
  deframe()


```
Run GSEA
```{r GSEA}
gsea.c2 <- fgseaMultilevel(pathways= react,
                           stats=ranking,  
                           minSize = 10, 
                           maxSize = 500)
head(gsea.c2[order(pval), ])
```
Show the results in a nice table
```{r C2 interactive table}
fgseaResTidy <- gsea.c2 %>%
  as_tibble() %>%
  arrange(desc(NES))

# Show in a nice table:
fgseaResTidy %>% 
  dplyr::select(-leadingEdge, -ES) %>% 
  arrange(padj) %>% 
  DT::datatable()
```

### Neutrophils and Platelets pathways
```{r}
# Searching for NEUTROPHILS AND PLATELET terms in the pathway, in case the are not among the top terms
neu_p.term <- grep("(NEUTROPHIL|PLATELET)",gsea.c2$pathway,ignore.case = TRUE, value = TRUE)
neu_terms <- gsea.c2 %>% 
  filter(pathway %in% neu_p.term) %>%
  filter(padj < 0.1) %>%
  arrange(desc(NES))
neu_terms
```

Select the top pathways
```{r C2 top pathways selection}
top_pos <- gsea.c2 %>%
  filter(padj < 0.1) %>%
  filter(NES > 0) %>%
  arrange(desc(NES)) %>%
  slice_head(n = 20)

top_neg <- gsea.c2 %>%
  filter(padj < 0.1) %>%
  filter(NES < 0) %>%
  arrange(NES) %>%
  slice_head(n = 20)

top_combined <- bind_rows(top_pos, top_neg)
```

### Plot the results using the Normalize Enrichment Score
```{r, fig.height= 10, fig.width= 18}
  gsea.c2.plot <- ggplot(top_combined, aes(reorder(pathway, NES), NES)) +
    geom_col(aes(fill = ifelse(NES > 0, "NES > 0", "NES < 0")), alpha = 0.8,width = 0.75,colour="black") +
    scale_fill_manual(values = c("NES > 0" = "#FF7F50", "NES < 0" = "#6495ED"), name = "FDR 10%") +
    coord_flip() +
    labs(x = "Pathway", y = "Normalized Enrichment Score",
         title = paste0("REACTOME top pathways in ",gse_id)) + 
    theme_bw() +
    theme(
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12,face = "bold"),
      axis.title = element_text(size = 14),
      legend.position = "top",
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )

gsea.c2.plot
```

```{r}
plotEnrichment(react[["REACTOME_NEUTROPHIL_DEGRANULATION"]],
               ranking) + labs(title="Neutrophil Degranulation")
```

```{r}
padj_val <- gsea.c2 %>%
  filter(pathway == "REACTOME_NEUTROPHIL_DEGRANULATION") %>%
  pull(padj)
padj_val <- signif(padj_val[1], 3)
padj_val
```

```{r}
plotEnrichment(react[["REACTOME_NEUTROPHIL_DEGRANULATION"]], ranking) +
  labs(
    title = "Neutrophil Degranulation",
    subtitle = paste("Adjusted p-value:", padj_val)
  )
```

```{r, fig.height= 8, fig.width= 18}
topPathwaysUp <- gsea.c2[ES > 0][head(order(pval), n=10), pathway]
topPathwaysDown <- gsea.c2[ES < 0][head(order(pval), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(react[topPathways], ranking, gsea.c2, 
              gseaParam=0.5)
```

```{r, fig.height= 4, fig.width= 16}
neu_terms_p <- neu_terms$pathway
plotGseaTable(react[neu_terms_p], ranking, gsea.c2, 
              gseaParam=0.5)
```


#### saving the results
```{r}
filename_fgsea <- paste0("../results/fgsea/REACTOME_results_",gse_id,".txt")
gs_clean <- gsea.c2 %>%
  mutate(across(where(is.list), ~ sapply(., function(x) paste(x, collapse = ","))))
write.table(gs_clean, filename_fgsea, quote = FALSE, sep = "\t", row.names = FALSE)
```

